<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>2017-02-28 漫谈iOS Crash收集框架</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><div class="content"><h3 id="-ios-crash-">漫谈iOS Crash收集框架</h3>
<blockquote>
<p>原文地址: 程序媛念茜 <a href="https://nianxi.net/ios/ios-crash-reporter.html">https://nianxi.net/ios/ios-crash-reporter.html</a></p>
</blockquote>
<p>为了能够第一时间发现程序问题，应用程序需要实现自己的崩溃日志收集服务，成熟的开源项目很多，如 <a href="https://github.com/kstenerud/KSCrash">KSCrash</a>，<a href="https://github.com/plausiblelabs/plcrashreporter">plcrashreporter</a>，<a href="https://github.com/kaler/CrashKit">CrashKit</a> 等。追求方便省心，对于保密性要求不高的程序来说，也可以选择各种一条龙Crash统计产品，如 <a href="http://try.crashlytics.com/">Crashlytics</a>，<a href="http://hockeyapp.net/features/crashreports/">Hockeyapp</a> ，<a href="http://www.umeng.com/umeng30_error_type">友盟</a>，<a href="http://bugly.qq.com/">Bugly</a> 等等。</p>
<ul>
<li>是否集成越多的Crash日志收集服务就越保险？</li>
<li>自己收集的Crash日志和系统生成的Crash日志有分歧，应该相信谁？</li>
<li>为什么有大量Crash日志显示崩在main函数里,但函数栈中却没有一行自己的代码？</li>
<li>野指针类的Crash难定位，有何妙招来应对？</li>
</ul>
<p>想解释清这些问题，必须从Mach异常说起</p>
<h4 id="mach-unix-">Mach异常与Unix信号</h4>
<p>iOS系统自带的 Apple’s Crash Reporter 记录在设备中的Crash日志，Exception Type项通常会包含两个元素： Mach异常 和 Unix信号。</p>
<pre><code><span class="hljs-built_in">Exception</span> <span class="hljs-built_in">Type</span>:         EXC_BAD_ACCESS (SIGSEGV)
<span class="hljs-built_in">Exception</span> Subtype:      KERN_INVALID_ADDRESS at <span class="hljs-number">0x041a6f3</span>
</code></pre><p>Mach异常是什么？它又是如何与Unix信号建立联系的？ Mach是一个XNU的微内核核心，Mach异常是指最底层的内核级异常，被定义在 <code>&lt;mach/exception_types.h&gt;</code>下 。每个thread，task，host都有一个异常端口数组，Mach的部分API暴露给了用户态，用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常，抓取Crash事件。</p>
<p>所有Mach异常都在host层被<code>ux_exception</code>转换为相应的Unix信号，并通过<code>threadsignal</code>将信号投递到出错的线程。iOS中的 POSIX API 就是通过 Mach 之上的 BSD 层实现的。</p>
<p><img src="https://nianxi.net/assets/img/blog/2015-06-27-posix-bsd-mach.png" alt="mach"></p>
<p>因此，<code>EXC_BAD_ACCESS (SIGSEGV)</code>表示的意思是：Mach层的EXC_BAD_ACCESS异常，在host层被转换成SIGSEGV信号投递到出错的线程。既然最终以信号的方式投递到出错的线程，那么就可以通过注册signalHandler来捕获信号:</p>
<pre><code>signal<span class="hljs-list">(<span class="hljs-keyword">SIGSEGV</span>,signalHandler)</span><span class="hljs-comment">;</span>
</code></pre><p>捕获Mach异常或者Unix信号都可以抓到crash事件，这两种方式哪个更好呢？ 优选Mach异常，因为Mach异常处理会先于Unix信号处理发生，如果Mach异常的handler让程序exit了，那么Unix信号就永远不会到达这个进程了。转换Unix信号是为了兼容更为流行的POSIX标准(SUS规范)，这样不必了解Mach内核也可以通过Unix信号的方式来兼容开发。</p>
<blockquote>
<p>因为硬件产生的信号(通过CPU陷阱)被Mach层捕获，然后才转换为对应的Unix信号；苹果为了统一机制，于是操作系统和用户产生的信号(通过调用<code>kill</code>和<code>pthread_kill)</code>也首先沉下来被转换为Mach异常，再转换为Unix信号。</p>
</blockquote>
<h5 id="crash-">Crash收集的实现思路</h5>
<p>正如上述所说，可以通过捕获Mach异常、或Unix信号两种方式来抓取crash事件，于是总结起来实现方案就一共有3种。</p>
<h6 id="1-mach-">1) Mach异常方式</h6>
<p><img src="https://nianxi.net/assets/img/blog/2015-06-27-catch-mach-exception.png" alt="Mach异常方式"></p>
<h6 id="2-unix-">2) Unix信号方式</h6>
<pre><code>signal<span class="hljs-list">(<span class="hljs-keyword">SIGSEGV</span>,signalHandler)</span><span class="hljs-comment">;</span>
</code></pre><h6 id="3-mach-unix-">3) Mach异常+Unix信号方式</h6>
<p>Github上多数开源项目都采用的这种方式，即使在优选捕获Mach异常的情况下，也放弃捕获EXC_CRASH异常，而选择捕获与之对应的SIGABRT信号。著名开源项目plcrashreporter在代码注释中给出了详细的解释：</p>
<blockquote>
<p>We still need to use signal handlers to catch SIGABRT in-process. The kernel sends an <code>EXC_CRASH</code> mach exception to denote SIGABRT termination. In that case, catching the Mach exception in-process leads to process deadlock in an uninterruptable wait. Thus, we fall back on BSD signal handlers for SIGABRT, and do not register for <code>EXC_CRASH</code>.</p>
</blockquote>
<p>另外，需要重点说明的是：对于应用级异常NSException，还需要特殊处理。 你是否见过崩溃在main函数的crash日志，但是函数栈里面没有你的代码：</p>
<pre><code>Thread <span class="hljs-number">0</span> Crashed:
<span class="hljs-number">0</span>       libsystem_kernel.dylib          <span class="hljs-number">0x3a61757c</span>   __semwait_signal_nocancel + <span class="hljs-number">0x18</span>
<span class="hljs-number">1</span>       libsystem_c.dylib               <span class="hljs-number">0x3a592a7c</span>   nanosleep$NOCANCEL + <span class="hljs-number">0xa0</span>
<span class="hljs-number">2</span>       libsystem_c.dylib               <span class="hljs-number">0x3a5adede</span>   usleep$NOCANCEL + <span class="hljs-number">0x2e</span>
<span class="hljs-number">3</span>       libsystem_c.dylib               <span class="hljs-number">0x3a5c7fe0</span>   <span class="hljs-built_in">abort</span> + <span class="hljs-number">0x50</span>
<span class="hljs-number">4</span>       libc++abi.dylib                 <span class="hljs-number">0x398f6cd2</span>   abort_message + <span class="hljs-number">0x46</span>
<span class="hljs-number">5</span>       libc++abi.dylib                 <span class="hljs-number">0x3990f6e0</span>   default_terminate_handler() + <span class="hljs-number">0xf8</span>
<span class="hljs-number">6</span>       libobjc.A.dylib                 <span class="hljs-number">0x3a054f62</span>   _objc_terminate() + <span class="hljs-number">0xbe</span>
<span class="hljs-number">7</span>       libc++abi.dylib                 <span class="hljs-number">0x3990d1c4</span>   <span class="hljs-built_in">std</span>::__terminate(<span class="hljs-keyword">void</span> (*)()) + <span class="hljs-number">0x4c</span>
<span class="hljs-number">8</span>       libc++abi.dylib                 <span class="hljs-number">0x3990cd28</span>   __cxa_rethrow + <span class="hljs-number">0x60</span>
<span class="hljs-number">9</span>       libobjc.A.dylib                 <span class="hljs-number">0x3a054e12</span>   objc_exception_rethrow + <span class="hljs-number">0x26</span>
<span class="hljs-number">10</span>      CoreFoundation                  <span class="hljs-number">0x2f7d7f30</span>   CFRunLoopRunSpecific + <span class="hljs-number">0x27c</span>
<span class="hljs-number">11</span>      CoreFoundation                  <span class="hljs-number">0x2f7d7c9e</span>   CFRunLoopRunInMode + <span class="hljs-number">0x66</span>
<span class="hljs-number">12</span>      GraphicsServices                <span class="hljs-number">0x346dd65e</span>   GSEventRunModal + <span class="hljs-number">0x86</span>
<span class="hljs-number">13</span>      UIKit                           <span class="hljs-number">0x32124148</span>   UIApplicationMain + <span class="hljs-number">0x46c</span>
<span class="hljs-number">14</span>      XXXXXX                          <span class="hljs-number">0x0003b1f2</span>   main + <span class="hljs-number">0x1f2</span>
<span class="hljs-number">15</span>      libdyld.dylib                   <span class="hljs-number">0x3a561ab4</span>   start + <span class="hljs-number">0x0</span>
</code></pre><p>可以看出是因为某个NSException导致程序Crash的，只有拿到这个NSException，获取它的<code>reason</code>，<code>name</code>，<code>callStackSymbols</code>信息才能确定出问题的程序位置。</p>
<pre><code><span class="hljs-comment">/* NSException Class Reference */</span>
<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;
<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *reason;
<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSArray</span> *callStackSymbols;
<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSArray</span> *callStackReturnAddresses;
</code></pre><p>方法很简单，可通过注册<code>NSUncaughtExceptionHandler</code>捕获异常信息:</p>
<pre><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> my_uncaught_exception_handler (<span class="hljs-built_in">NSException</span> *exception) {
    <span class="hljs-comment">//这里可以取到 NSException 信息</span>
}
<span class="hljs-built_in">NSSetUncaughtExceptionHandler</span>(&amp;my_uncaught_exception_handler);
</code></pre><p>将拿到的NSException细节写入Crash日志，精准的定位出错程序位置：</p>
<pre><code>Application Specific Information:
*** Terminating app due to uncaught exception <span class="hljs-string">'NSUnknownKeyException'</span>, reason: <span class="hljs-string">'[&lt;__NSDictionaryI 0x14554d00&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key key.'</span>

Last Exception Backtrace:
<span class="hljs-number">0</span> CoreFoundation <span class="hljs-number">0x2f8a3f7e</span>     __exceptionPreprocess + <span class="hljs-number">0x7e</span>
<span class="hljs-number">1</span> libobjc.A.dylib <span class="hljs-number">0x3a054cc</span>     objc_exception_throw + <span class="hljs-number">0x22</span>
<span class="hljs-number">2</span> CoreFoundation <span class="hljs-number">0x2f8a3c94</span>     -[NSException raise] + <span class="hljs-number">0x4</span>
<span class="hljs-number">3</span> Foundation <span class="hljs-number">0x301e8f1e</span>         -[NSObject(NSKeyValueCoding) setValue:forKey:] + <span class="hljs-number">0xc6</span>
<span class="hljs-number">4</span> DemoCrash <span class="hljs-number">0x00085306</span>          -[ViewController crashMethod] + <span class="hljs-number">0x6e</span>
<span class="hljs-number">5</span> DemoCrash <span class="hljs-number">0x00084ecc</span>          main + <span class="hljs-number">0x1cc</span>
<span class="hljs-number">6</span> DemoCrash <span class="hljs-number">0x00084cf8</span>          start + <span class="hljs-number">0x24</span>
</code></pre><p>那么，是不是收到了大量crash在main函数却没有NSException信息的日志，就代表自己集成的Crash日志收集服务没有注册NSUncaughtExceptionHandler呢？不一定，还有另外一种可能，就是被同时存在的其他Crash日志收集服务给坑了。</p>
<h5 id="-crash-">多个Crash日志收集服务共存的坑</h5>
<p>是的，在自己的程序里集成多个Crash日志收集服务实在不是明智之举。通常情况下，第三方功能性SDK都会集成一个Crash收集服务，以及时发现自己SDK的问题。当各家的服务都以保证自己的Crash统计正确完整为目的时，难免出现时序手脚，强行覆盖等等的恶意竞争，总会有人默默被坑。</p>
<h6 id="1-uncaughtexceptionhandler">1) 拒绝传递 UncaughtExceptionHandler</h6>
<p>如果同时有多方通过NSSetUncaughtExceptionHandler注册异常处理程序，和平的作法是：后注册者通过NSGetUncaughtExceptionHandler将先前别人注册的handler取出并备份，在自己handler处理完后自觉把别人的handler注册回去，规规矩矩的传递。不传递强行覆盖的后果是，在其之前注册过的日志收集服务写出的Crash日志就会因为取不到NSException而丢失<code>Last Exception Backtrace</code>等信息。（P.S. iOS系统自带的Crash Reporter不受影响）</p>
<p>在开发测试阶段，可以利用 <a href="https://github.com/facebook/fishhook">fishhook</a> 框架去hookNSSetUncaughtExceptionHandler方法，这样就可以清晰的看到handler的传递流程断在哪里，快速定位污染环境者。不推荐利用调试器添加符号断点来检查，原因是一些Crash收集框架在调试状态下是不工作的。</p>
<p>检测代码示例：</p>
<pre><code><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSUncaughtExceptionHandler</span> *g_vaildUncaughtExceptionHandler;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> (*ori_<span class="hljs-built_in">NSSetUncaughtExceptionHandler</span>)( <span class="hljs-built_in">NSUncaughtExceptionHandler</span> * );

<span class="hljs-keyword">void</span> my_<span class="hljs-built_in">NSSetUncaughtExceptionHandler</span>( <span class="hljs-built_in">NSUncaughtExceptionHandler</span> * handler)
{
    g_vaildUncaughtExceptionHandler = <span class="hljs-built_in">NSGetUncaughtExceptionHandler</span>();
    <span class="hljs-keyword">if</span> (g_vaildUncaughtExceptionHandler != <span class="hljs-literal">NULL</span>) {
        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"UncaughtExceptionHandler=%p"</span>,g_vaildUncaughtExceptionHandler);
    }

    ori_<span class="hljs-built_in">NSSetUncaughtExceptionHandler</span>(handler);
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,[<span class="hljs-built_in">NSThread</span> callStackSymbols]);

    g_vaildUncaughtExceptionHandler = <span class="hljs-built_in">NSGetUncaughtExceptionHandler</span>();
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"UncaughtExceptionHandler=%p"</span>,g_vaildUncaughtExceptionHandler);
}
</code></pre><p>对于越狱插件注入应用进程内部，恶意覆盖NSSetUncaughtExceptionHandler的情况，应用程序本身处理起来比较弱势，因为越狱环境下操作时序的玩法比较多权利比较大。</p>
<h6 id="2-mach-handler-">2) Mach异常端口换出+信号处理Handler覆盖</h6>
<p>和NSSetUncaughtExceptionHandler的情况类似，设置过的Mach异常端口和信号处理程序也有可能被干掉，导致无法捕获Crash事件。</p>
<h6 id="3-">3) 影响系统崩溃日志准确性</h6>
<p>应用层参与收集Crash日志的服务方越多，越有可能影响iOS系统自带的Crash Reporter。由于进程内线程数组的变动，可能会导致系统日志中线程的<code>Crashed</code> 标签标记错位，可以搜索<code>abort()</code>等关键字来复查系统日志的准确性。 若程序因NSException而Crash，系统日志中的<code>Last Exception Backtrace</code>信息是完整准确的，不会受应用层的胡来而影响，可作为排查问题的参考线索。</p>
<h5 id="objc-crash">ObjC野指针类的Crash</h5>
<p>收集Crash日志这个步骤没有问题的情况下，还是有很多全系统栈的日志的情况，没有自己一行代码，分析起来十分棘手，ObjC野指针类的Crash正是如此，这里推荐几篇好文章：</p>
<ul>
<li><a href="http://bugly.qq.com/blog/?p=200">如何定位Obj-C野指针随机Crash(一)：先提高野指针Crash率</a></li>
<li><a href="http://bugly.qq.com/blog/?p=308">如何定位Obj-C野指针随机Crash(二)：让非必现Crash变成必现</a></li>
<li><a href="http://bugly.qq.com/blog/?p=335">如何定位Obj-C野指针随机Crash(三)：加点黑科技让Crash自报家门</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2008/09/22/objc_explain_So_you_crashed_in_objc_msgSend.html">分析objc_msgSend()处崩溃的小技巧</a></li>
</ul>
<p>除此之外，在Crash日志中补充记录一些额外信息可以辅助定位，如切面标记线程出处、队列出处，记录用户操作轨迹等等……</p>
</div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/withhebing" class="author-name">withhebing</a>-<a href="https://github.com/withhebing/diary" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>